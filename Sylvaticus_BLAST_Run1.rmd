---
title: "R Notebook"
output: html_notebook
---

---
title: "Sylvaticus_consensus_final"
output: html_notebook
---

```{r}
# Load the packages
library(tidyverse)
library(here)
```



# How do i go about the Mus musculus
Need to take out 3 words instead of 2 when doing the species column 
but then this will include words strain genome etc for the other species
Can i remove all last words apart from the names beginning with "mus musculus"
however there is one mus musculus alone, others
Mus musculus domesticus
Mus musculus Castaneus
Mus musculus musculus
Mus musculus

Maybe i could remove all last word apart from those including 
"Mus musculus domesticus"
"Mus musculus Castaneus"
"Mus musculus musculus"


take only the first 3 words only if they start with mus musculus
combine mus musculus as one word and then 





REAL WORK STARTS HERE









# start from beginning 
```{r}
Sylvaticus_new <- read_tsv(here::here("", "../consensus_sylvaticus_final_output.txt"), col_names=F) %>% 
  rename("Query_seq_id" = X1,
         "Subject_seq_id" = X2,
         "Evalue" = X3,
         "Identical_matches_perc" = X4,
         "bitscore" = X5,
         "subject_title" = X6)

head(Sylvaticus_new)
```


```{r}
# Extract the first 3 words from the subject title
Sylvaticus_new <- Sylvaticus_new %>% mutate(species = word(subject_title, 1, 3))

tail(Sylvaticus_new)

Sylvaticus_new %>% count(Query_seq_id)
```

```{r}
# need to substitute "Mus musculus" to "Musmusculus" so its one word
Sylvaticus_new$species <- gsub("Mus musculus", "Musmusculus", Sylvaticus_new$species)

Sylvaticus_new %>% filter(str_detect(species, "Musmusculus"))


```

```{r}

# need to extract 2 words
Sylvaticus_new$species <- Sylvaticus_new$species %>% word(1, 2)

# need to convert mus musculus back to normal 
Sylvaticus_new$species <- gsub("Musmusculus", "Mus musculus", Sylvaticus_new$species)

Sylvaticus_new %>% select(species) %>% unique()

```


```{r}
# the Mus musculus need to not have a third word 
Sylvaticus_new$species <- gsub("Mus musculus chromosome", "Mus musculus", Sylvaticus_new$species)
Sylvaticus_new$species <- gsub("Mus musculus unplaced", "Mus musculus", Sylvaticus_new$species)
Sylvaticus_new %>% select(species) %>% unique() %>% nrow()
# now have the correct amount 21 species


Sylvaticus_new %>% select(-subject_title)
```

```{r}
# split the dataframe to subdataframes for each consensus_id
unique_consensus_ID <- split(Sylvaticus_new,f=Sylvaticus_new$Query_seq_id)
```

```{r}
# check how the bitscore is arranged
unique_consensus_ID[[1]] 
# goes from highest to lowest for each species

# want to make sure when removing duplicated rows of species that you are actually keeping the highest bitscore
unique_consensus_ID[[1]] %>% group_by(species) %>% arrange(desc(bitscore))

# do this for all the dataframes
unique_consensus_ID <- lapply(unique_consensus_ID, function(x) {x %>% group_by(species) %>% arrange(desc(bitscore))})


# check
unique_consensus_ID[[1]]
```


```{r}
# remove all duplicated species for 1 subdataframe
unique_consensus_ID[[1]][!duplicated(unique_consensus_ID[[1]]$species),]

# now do it across all dataframes
unique_consensus_ID <- lapply(unique_consensus_ID, function(x) { x[!duplicated(x$species),]})  

# check if worked, yes, contains only one species per locus
unique_consensus_ID[[1]]
```



put back into one big dataframe so can calculate overall results
```{r}
# collapse dataframe rows one after the other
filtered_sylvaticus <- bind_rows(unique_consensus_ID)
```

```{r}
# want to calculate how many each consensus has a unique species
# Dataframe is still grouped by species therefore need to ungroup the whole thing
filtered_sylvaticus <- filtered_sylvaticus %>% ungroup()

head(filtered_sylvaticus)

# now can calculate the number of times a unique query id is repeated and put in descending order
loci_sites <- filtered_sylvaticus %>% count(Query_seq_id) %>% arrange(desc(n))


```

do this table the other way round in order to plot
Thousand loci sites how many species are there
filtering by number of loci site to see how many species are left
e.g. 1 species how many loci sites for this 
2 etc etc up til 21


```{r}
loci_sites

# this counts the number of times each number has been repeated and mutate it into a new row, then arranges it from highest to lowest
loci_sites <- loci_sites %>% group_by(n) %>% mutate(number_of_loci=seq(n())) %>% arrange(desc(number_of_loci)) 
loci_sites

# This is to remove all the numbers except for the first
loci_sites <- loci_sites %>% ungroup()
loci_sites <- loci_sites[!duplicated(loci_sites$n),] %>% arrange(desc(n)) %>% select(n, number_of_loci)
loci_sites

# check if values are right, look at number of rows
filtered_sylvaticus %>% count(Query_seq_id) %>% arrange(desc(n)) %>% filter(n == 21)


# rename the column so can plot 
loci_sites <- loci_sites %>% rename("number_of_species" = n)
loci_sites
```

# need a plot for the number of species on one axis on other axis number of loci site for this given number of species 


```{r}
ggplot(loci_sites) + aes(x = number_of_species, y = number_of_loci) + geom_point() + scale_x_continuous(limits = c(1,21), breaks = seq(1,21,1))
```

```{r}


# lets zoom in to the 1000

filter(loci_sites, number_of_loci <1000) %>% ggplot() + aes(x = number_of_species, y = number_of_loci) + geom_point() + scale_x_continuous(limits = c(1,21), breaks = seq(1,21,1))

filter(loci_sites, number_of_loci <1000) %>% ggplot() + aes(x = number_of_species, y = number_of_loci) + geom_point() + scale_x_continuous(limits = c(5,21), breaks = seq(5,21,1))
```
# multiple sequence alignment 
package 
MSA

have to align the loci sites

Combine all the loci into one long sequence
for example for 13, would have around 600 
Combine all the loci in the right order
figure out the 13 species
Select all the loci that are common
For each of the species combine all the loci sites
Would give you 13 sequences
Thsi would be used as an input for MSA


Could try first on for example 3 species
and see how it would align
MSA produce an alignment: use this for iq-tree
Need to know what iq-tree needs for an input etc. 

once have divergence and substitution model: would have everything for the dissertation project




For iq-tree need an alignment input
NEed to really understand IQ-tree


Model finder for iq-tree





so first thing is to find a way to extract the loci sites from the original files. 
using the Loci ID's 
```{r}
filtered_sylvaticus

R15 <- filtered_sylvaticus %>% count(Query_seq_id) %>% arrange(desc(n)) %>% filter(n == 15) %>% select(Query_seq_id)

test1 <- filter(filtered_sylvaticus, Query_seq_id %in% R15$Query_seq_id) %>% select(Query_seq_id, species) 
# 4,380 rows 
15*292 # 4,380 which is the correct amount of rows

test1

# but the 15 species are not the same for all of them 
test1$species %>% unique()
# ARGHHHHHHH WHAT NOW!?

# ONE CONSENSUS HAS MAPPED TO only 15 SPECIES BUT THE 15 SPECIES ARE NOT NECESSARILY THE SAME for the other loci/consensus 

test %>% filter(species == "Apodemus sylvaticus")



```
# lets start with a small number




```{r}
R3 <- filtered_sylvaticus %>% count(Query_seq_id) %>% arrange(desc(n)) %>% filter(n == 3) %>% select(Query_seq_id)

test <- filter(filtered_sylvaticus, Query_seq_id %in% R3$Query_seq_id) %>% select(Query_seq_id, species) 
# 4,380 rows 
15*292 # 4,380 which is the correct amount of rows

test

# but the 15 species are not the same for all of them 
test$species %>% unique()
# ARGHHHHHHH WHAT NOW!?

# ONE CONSENSUS HAS MAPPED TO only 15 SPECIES BUT THE 15 SPECIES ARE NOT NECESSARILY THE SAME for the other loci/consensus 

test %>% filter(species == "Apodemus sylvaticus")

unique_species_all <- unique(filtered_sylvaticus$species)
```
# combinations of 3
```{r}
# NEED TO HAVE THE ID AND SPECIES INTO ONE TABLE NOT JUST THE NUMBER
R3 <- filtered_sylvaticus %>% count(Query_seq_id) %>% arrange(desc(n)) %>% filter(n == 3) %>% select(Query_seq_id)
R3
test <- filter(filtered_sylvaticus, Query_seq_id %in% R3$Query_seq_id) %>% select(Query_seq_id, species) 



R21 <- filtered_sylvaticus %>% count(Query_seq_id) %>% arrange(desc(n)) %>% filter(n == 21) %>% select(Query_seq_id)
test_21 <- filter(filtered_sylvaticus, Query_seq_id %in% R21$Query_seq_id) %>% select(Query_seq_id, species) 
test_21 %>% arrange(Query_seq_id)

# now start the combination process
possible_3 <- combn(unique_species_all, 3, FUN= NULL, simplify = F)
test
test %>% 
  group_by(Query_seq_id) %>% 
  filter(species %in% possible_3[[1]]) %>% 
  count(Query_seq_id) 
# PROBLEM!!! IT SHOWS IF ITS MATCHED TO ANY ONE OF THE COMBINATION [1] NOT IF ITS MATCHED TO ALL 3

# can do this 
test %>% 
  filter(species %in% possible_3[[1]]) %>% 
  count(Query_seq_id) %>% 
  filter(n == 3) %>% 
  nrow() 


# so there is 81 for combination 1 now need to do this for all combinations 
a <- 1:length(possible_3)
a
for (i in 1:length(possible_3)) {
  b <- test %>% 
  filter(species %in% possible_3[[i]]) %>% 
  count(Query_seq_id) %>% 
  filter(n == 3) %>% 
  nrow() 
  a[i] <- b
}

# this puts into a table: the combination number and the number of Loci that had this combination, however, does not display the species name neither the loci's

matches <- bind_cols(c(1:length(possible_3)),a) %>% # need a function to put the list of species name into the column 
  rename("Combination_number" = ...1,
         "number_of_matches" = ...2) %>% 
  arrange(desc(number_of_matches))

# combination number 12 has the highest number of matches 
possible_3[12] # "Apodemus sylvaticus" "Apodemus speciosus" 
"Mastomys coucha"    

highest_match <- possible_3[(pull(matches[1,1]))]


# this could be an easy solution also gives the same 3 species 
test %>% count(species) %>% arrange(desc(n))


# NOW TRYING TO FIND ALL 3 SPECIES FOR EACH ID. 

test %>% 
  group_by(Query_seq_id) %>% 
  filter(species %in% highest_match)

# notes
possible_3
as.data.frame(possible_3)
possible_3 %>% rbind()

bind_cols(c(1:length(possible_3)),a) %>% 
  rename("Combination_number" = ...1,
         "number_of_matches" = ...2) %>% 
  arrange(desc(number_of_matches))

pull(matches[1,1])

filter_function <- function(df) {
  df %>% filter(species %in% c("Apodemus sylvaticus","Apodemus speciosus","Mastomys coucha"))
}
test_2 <- test %>% group_by(Query_seq_id) %>% nest() %>% mutate(filtered_data = map(data, filter_function)) %>% unnest(filtered_data) %>% arrange(Query_seq_id)

test_2 %>% count(Query_seq_id) %>% filter(n == 3)

# do this with 5 if it drops below 100 loci, if less do 4 then if more do 7.


  
```

```{r}
for (i in 1:21) {
  paste0("possible", i) <- combn(unique_species_all, i, FUN = NULL, simplify = F)
}

for (i in 1:21) {
  paste0("possible", i)
}

possible_3 <- combn(unique_species_all, 3, FUN= NULL, simplify = F)
```



```{r}
highest_match <- possible_3[(pull(matches[1,1]))]

filter()
```




```{r}


# MAYBE LETS CREATE A FUNCTION FOR ALL THIS


maximum_possibility <- function(df,number) {
results <- 1:length(df)
for (i in 1:length(df)) {
  b <- test %>% 
  filter(species %in% df[[i]]) %>% 
  count(Query_seq_id) %>% 
  filter(n == number) %>% 
  nrow() 
  results[i] <- b
}
matches <- bind_cols(c(1:length(df)),results) %>% 
  rename("Combination_number" = ...1,
         "number_of_matches" = ...2) %>% 
  arrange(desc(number_of_matches))

highest_match <- df[(pull(matches[1,1]))]
}

possible_4 <- combn(unique_species_all, 4, FUN= NULL, simplify = F)
maximum_possibility(possible_4, 4)
highest_match


# ARGHHHHHHH THIS IS DRIVING ME INSANE 
```
# MAFFT 
# model for the sequence
splitting sequence into 100 or 200 would change the substitution model 




# end of dissertation
take 292 sequence
multiple sequence alignment
and input IQ tree, would input the alignment 
then figuring it out what it means 
Discussion 

```{r}

```










# Combination of 2
```{r}
# NEED TO HAVE THE ID AND SPECIES INTO ONE TABLE NOT JUST THE NUMBER
R2 <- filtered_sylvaticus %>% count(Query_seq_id) %>% arrange(desc(n)) %>% filter(n == 2) %>% select(Query_seq_id)
R2
test <- filter(filtered_sylvaticus, Query_seq_id %in% R2$Query_seq_id) %>% select(Query_seq_id, species) 



# now start the combination process
possible_2 <- combn(unique_species_all, 2, FUN= NULL, simplify = F)
test
test %>% 
  group_by(Query_seq_id) %>% 
  filter(species %in% possible_2[[1]]) %>% 
  count(Query_seq_id) 
# PROBLEM!!! IT SHOWS IF ITS MATCHED TO ANY ONE OF THE COMBINATION [1] NOT IF ITS MATCHED TO ALL 2

# can do this 
test %>% 
  filter(species %in% possible_2[[1]]) %>% 
  count(Query_seq_id) %>% 
  filter(n == 2) %>% 
  nrow() 


# so there is 81 for combination 1 now need to do this for all combinations 
a <- 1:length(possible_2)
a
for (i in 1:length(possible_2)) {
  b <- test %>% 
  filter(species %in% possible_2[[i]]) %>% 
  count(Query_seq_id) %>% 
  filter(n == 2) %>% 
  nrow() 
  a[i] <- b
}

# this puts into a table: the combination number and the number of Loci that had this combination, however, does not display the species name neither the loci's
a
matches <- bind_cols(c(1:length(possible_2)),a) %>% # need a function to put the list of species name into the column 
  rename("Combination_number" = ...1,
         "number_of_matches" = ...2) %>% 
  arrange(desc(number_of_matches))

# combination number 12 has the highest number of matches 
possible_3[12] # "Apodemus sylvaticus" "Apodemus speciosus" 
"Mastomys coucha"    

highest_match <- possible_2[(pull(matches[1,1]))]


# this could be an easy solution also gives the same 3 species 
test %>% count(species) %>% arrange(desc(n))


# NOW TRYING TO FIND ALL 3 SPECIES FOR EACH ID. 

test %>% 
  group_by(Query_seq_id) %>% 
  filter(species %in% highest_match)

# notes
possible_3
as.data.frame(possible_3)
possible_3 %>% rbind()

bind_cols(c(1:length(possible_3)),a) %>% 
  rename("Combination_number" = ...1,
         "number_of_matches" = ...2) %>% 
  arrange(desc(number_of_matches))

pull(matches[1,1])

filter_function <- function(df) {
  df %>% filter(species %in% c("Apodemus sylvaticus","Apodemus speciosus","Mastomys coucha"))
}
test_2 <- test %>% group_by(Query_seq_id) %>% nest() %>% mutate(filtered_data = map(data, filter_function)) %>% unnest(filtered_data) %>% arrange(Query_seq_id)

test_2 %>% count(Query_seq_id) %>% filter(n == 3)

# do this with 5 if it drops below 100 loci, if less do 4 then if more do 7.


  
```

